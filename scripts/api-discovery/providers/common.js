const fs = require('fs');
const path = require('path');
const axios = require('axios');

const OUTPUT_DIR = path.join(__dirname, '..', 'output');

function readEnvLocal() {
  const envPath = path.resolve(process.cwd(), '.env.local');
  if (!fs.existsSync(envPath)) return {};
  const lines = fs.readFileSync(envPath, 'utf8').split(/\r?\n/);
  const env = {};
  for (const line of lines) {
    const m = line.match(/^([A-Z0-9_]+)=(.*)$/);
    if (m) env[m[1]] = m[2];
  }
  return env;
}

function ensureDir(p) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
}

function writeJson(provider, kind, data) {
  ensureDir(OUTPUT_DIR);
  const jsonPath = path.join(OUTPUT_DIR, `${provider}-${kind}.json`);
  fs.writeFileSync(jsonPath, JSON.stringify(data, null, 2));
  return jsonPath;
}

function writeModelsMd(provider, models) {
  const docsDir = path.resolve(process.cwd(), 'docs', 'api-integration', 'providers', provider);
  ensureDir(docsDir);
  const mdPath = path.join(docsDir, 'models.md');
  const lines = [];
  lines.push(`# ${provider.toUpperCase()} Model Catalog`);
  lines.push('');
  lines.push('_Generated by scripts/api-discovery — review before committing._');
  lines.push('');
  lines.push('## Models');
  lines.push('');
  if (!models || models.length === 0) {
    lines.push('No models discovered. Implement provider discovery or check credentials.');
  } else {
    for (const m of models) {
      const caps = [];
      if (m.supportsVision || m.supportsImageInput) caps.push('vision');
      if (m.supportsDocuments) caps.push('docs');
      if (m.supportsImageGeneration) caps.push('image-gen');
      if (m.supportsVideoGeneration) caps.push('video-gen');
      if (m.supportsVoiceInput || m.supportsVoiceOutput) caps.push('voice');
      if (m.supportsRealtime) caps.push('realtime');
      const capsStr = caps.length ? ` [${caps.join(', ')}]` : '';
      lines.push(`- ${m.id}${m.name ? ` — ${m.name}` : ''}${capsStr}`);
    }
  }
  fs.writeFileSync(mdPath, lines.join('\n'));
  return mdPath;
}

async function safeGet(url, config = {}) {
  const client = axios.create({ timeout: 8000 });
  const res = await client.get(url, config);
  return res.data;
}

module.exports = {
  readEnvLocal,
  ensureDir,
  writeJson,
  writeModelsMd,
  safeGet,
  OUTPUT_DIR,
};

// Heuristic metadata parser shared by providers. Extracts capabilities if
// provider model objects expose structured or semi-structured fields.
function deriveCapsFromMetadata(obj = {}) {
  const textBlob = JSON.stringify(obj).toLowerCase();

  // Check common structured fields first
  const caps = obj.capabilities || obj.features || obj.modalities || obj.modes || obj.tags || {};
  const arrCaps = Array.isArray(caps) ? caps.map(String) : typeof caps === 'object' ? Object.keys(caps).filter(k => caps[k]) : [];
  const arr = new Set(arrCaps.map(s => String(s).toLowerCase()));

  const has = (re) => re.test(textBlob) || [...arr].some(x => re.test(x));

  return {
    supportsVision: has(/vision|multimodal|image[_-]?input|pixtral|vl\b/),
    supportsImageInput: has(/vision|multimodal|image[_-]?input|vl\b/),
    supportsDocuments: has(/document|pdf|file[_-]?input|docx|markdown/),
    supportsImageGeneration: has(/image[_-]?gen|image[- ]generation|dall[- ]e|imagen|flux|sdxl|stable[- ]diffusion/),
    supportsVideoGeneration: has(/video[- ]generation|video[_-]?gen|veo|sora|genmo|pika|kling|luma/),
    supportsVoiceInput: has(/speech[_-]?to[_-]?text|asr|audio[_-]?input|realtime\b.*audio/),
    supportsVoiceOutput: has(/text[_-]?to[_-]?speech|tts|audio[_-]?output/),
    supportsRealtime: has(/realtime|live|websocket/),
  };
}

module.exports.deriveCapsFromMetadata = deriveCapsFromMetadata;
