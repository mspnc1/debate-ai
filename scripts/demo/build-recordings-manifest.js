const fs = require('fs');
const path = require('path');

const recordingsDir = path.join(__dirname, 'recordings');
const destRecordingsDir = path.join(__dirname, '..', '..', 'src', 'assets', 'demo', 'recordings');
const outputPath = path.join(__dirname, '..', '..', 'src', 'assets', 'demo', 'recordingsManifest.ts');

const providerMap = {
  c: 'claude',
  o: 'openai',
  g: 'google',
};

if (!fs.existsSync(destRecordingsDir)) {
  fs.mkdirSync(destRecordingsDir, { recursive: true });
} else {
  for (const existing of fs.readdirSync(destRecordingsDir)) {
    if (existing.endsWith('.json')) {
      fs.unlinkSync(path.join(destRecordingsDir, existing));
    }
  }
}

const files = fs.readdirSync(recordingsDir)
  .filter((file) => file.endsWith('.json'))
  .sort();

const imports = new Set();
const entries = [];

function parseProviders(token) {
  const chars = token.split('');
  const providers = chars
    .map((ch) => providerMap[ch])
    .filter(Boolean);
  const unique = Array.from(new Set(providers));
  unique.sort((a, b) => {
    const order = ['claude', 'openai', 'google'];
    return order.indexOf(a) - order.indexOf(b);
  });
  return unique;
}

for (const file of files) {
  const filePath = path.join(recordingsDir, file);
  const raw = fs.readFileSync(filePath, 'utf8');
  let data;
  try {
    data = JSON.parse(raw);
  } catch (error) {
    console.warn(`Skipping ${file}: failed to parse JSON`, error);
    continue;
  }

  const id = path.basename(file, '.json');
  const [type, providerToken] = id.split('_');
  if (!type || !providerToken) {
    console.warn(`Skipping ${file}: unable to parse type/providers from id ${id}`);
    continue;
  }

  const providers = parseProviders(providerToken);
  if (providers.length === 0) {
    console.warn(`Skipping ${file}: no providers resolved for token ${providerToken}`);
    continue;
  }

  const importName = `recording_${id.replace(/[^a-zA-Z0-9_]/g, '_')}`;
  const importPath = `./recordings/${file}`;
  imports.add(`import ${importName} from '${importPath}';`);

  let title = undefined;
  let topic = undefined;
  if (type === 'chat' || type === 'compare') {
    title = data.title || null;
  }
  if (type === 'debate') {
    topic = data.topic || null;
    title = data.title || data.topic || null;
  }

  let displayTitle = title ?? topic ?? id;
  if (type === 'debate') {
    const personaToken = id.split('_')[2] || '';
    if (personaToken.toLowerCase() === 'default') {
      displayTitle = `${displayTitle} (Default)`;
    } else if (personaToken) {
      const label = personaToken.replace(/_/g, ' ');
      displayTitle = `${displayTitle} (${label.replace(/\b\w/g, (ch) => ch.toUpperCase())} persona)`;
    }
  }

  entries.push({
    id,
    type,
    providers,
    importName,
    title: displayTitle ?? null,
    topic: topic ?? null,
  });

  const destPath = path.join(destRecordingsDir, file);
  fs.copyFileSync(filePath, destPath);
}

const lines = [];
lines.push('// Auto-generated by scripts/demo/build-recordings-manifest.js');
lines.push('// Do not edit directly.');
lines.push("import type { DemoChat, DemoCompare, DemoDebate } from '@/types/demo';");
lines.push(...Array.from(imports));
lines.push('');
lines.push('export type DemoRecordingType = \'' + ['chat', 'compare', 'debate'].join("' | '") + '\';');
lines.push('');
lines.push('export interface DemoRecordingEntry<T = DemoChat | DemoCompare | DemoDebate> {');
lines.push('  id: string;');
lines.push('  type: DemoRecordingType;');
lines.push('  providers: string[];');
lines.push('  title?: string | null;');
lines.push('  topic?: string | null;');
lines.push('  data: T;');
lines.push('}');
lines.push('');
lines.push('export const demoRecordings: DemoRecordingEntry[] = [');

entries.forEach((entry, index) => {
  const { id, type, providers, importName, title, topic } = entry;
  const providerArr = providers.map((p) => `'${p}'`).join(', ');
  const dataCast = type === 'chat' ? '(DemoChat)' : type === 'compare' ? '(DemoCompare)' : '(DemoDebate)';
  lines.push('  {');
  lines.push(`    id: '${id}',`);
  lines.push(`    type: '${type}',`);
  lines.push(`    providers: [${providerArr}],`);
  if (title !== null) {
    lines.push(`    title: ${title ? JSON.stringify(title) : 'null'},`);
  }
  if (topic !== null) {
    lines.push(`    topic: ${topic ? JSON.stringify(topic) : 'null'},`);
  }
  lines.push(`    data: ${importName} as unknown as ${dataCast},`);
  lines.push('  }' + (index === entries.length - 1 ? '' : ','));
});

lines.push('];');
lines.push('');
lines.push('export const recordingsById = new Map(demoRecordings.map((entry) => [entry.id, entry]));');
lines.push('');
lines.push('export function getRecordingsByProviders<T extends DemoChat | DemoCompare | DemoDebate>(');
lines.push('  type: DemoRecordingType,');
lines.push('  providers: string[]');
lines.push('): DemoRecordingEntry<T>[] {');
lines.push("  const normalized = comboKey(providers);");
lines.push('  return demoRecordings.filter((entry) => entry.type === type && comboKey(entry.providers) === normalized) as DemoRecordingEntry<T>[];');
lines.push('}');
lines.push('');
lines.push('export function comboKey(providers: string[]): string {');
lines.push("  const allowed = ['claude', 'openai', 'google'];");
lines.push('  const normalized = Array.from(new Set(providers.map((p) => p.toLowerCase()))).filter((p) => allowed.includes(p));');
lines.push('  normalized.sort((a, b) => allowed.indexOf(a) - allowed.indexOf(b));');
lines.push("  return normalized.join('+');");
lines.push('}');

fs.writeFileSync(outputPath, lines.join('\n') + '\n');

console.log(`Generated manifest with ${entries.length} recordings -> ${path.relative(process.cwd(), outputPath)}`);
