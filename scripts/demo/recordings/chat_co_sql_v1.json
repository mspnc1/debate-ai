{
  "type": "chat",
  "id": "chat_co_sql_v1",
  "title": "Code review: VoiceRecorder (Claude + ChatGPT)",
  "comboKey": "claude+openai",
  "tags": ["code-review", "react-native"],
  "events": [
    {
      "type": "message",
      "role": "user",
      "content": "Can you both review this shared VoiceRecorder component? I'm worried about memory leaks and missing accessibility.```tsx\nexport function VoiceRecorder({ onStop }) {\n  const [isRecording, setIsRecording] = React.useState(false);\n  const mediaRecorder = React.useRef(null);\n\n  const start = async () => {\n    const permission = await Audio.requestPermissionsAsync();\n    if (!permission.granted) return;\n    const recorder = new Audio.Recording();\n    await recorder.prepareToRecordAsync(Audio.RECORDING_OPTIONS_PRESET_HIGH_QUALITY);\n    await recorder.startAsync();\n    mediaRecorder.current = recorder;\n    setIsRecording(true);\n  };\n\n  const stop = async () => {\n    await mediaRecorder.current.stopAndUnloadAsync();\n    const uri = mediaRecorder.current.getURI();\n    setIsRecording(false);\n    onStop(uri);\n  };\n\n  return (\n    <Pressable onPress={isRecording ? stop : start} style={{ padding: 16, backgroundColor: isRecording ? '#c62828' : '#2962ff' }}>\n      <Text style={{ color: 'white' }}>{isRecording ? 'Stop' : 'Start'} recording</Text>\n    </Pressable>\n  );\n}\n```"
    },
    {
      "type": "message",
      "role": "assistant",
      "speakerProvider": "claude",
      "content": "My review focuses on resource cleanup and explicit lifecycle handling. I'd suggest using `useEffect` to release the recorder if the component unmounts, plus guard the stop handler. Here's a rewritten version with structured error handling.```tsx\nimport React from 'react';\nimport { Pressable, Text, AccessibilityInfo } from 'react-native';\nimport { Audio } from 'expo-av';\n\ntype VoiceRecorderProps = { onStop: (uri: string | null) => void };\n\nexport function VoiceRecorder({ onStop }: VoiceRecorderProps): JSX.Element {\n  const [isRecording, setIsRecording] = React.useState(false);\n  const recorderRef = React.useRef<Audio.Recording | null>(null);\n\n  React.useEffect(() => {\n    return () => {\n      if (recorderRef.current) {\n        recorderRef.current.stopAndUnloadAsync().catch(() => undefined);\n      }\n    };\n  }, []);\n\n  const startAsync = React.useCallback(async () => {\n    const { granted } = await Audio.requestPermissionsAsync();\n    if (!granted) {\n      AccessibilityInfo.announceForAccessibility('Microphone permission is required.');\n      return;\n    }\n\n    const recording = new Audio.Recording();\n    await recording.prepareToRecordAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY);\n    await recording.startAsync();\n    recorderRef.current = recording;\n    setIsRecording(true);\n  }, []);\n\n  const stopAsync = React.useCallback(async () => {\n    if (!recorderRef.current) return;\n    await recorderRef.current.stopAndUnloadAsync();\n    const uri = recorderRef.current.getURI();\n    recorderRef.current = null;\n    setIsRecording(false);\n    onStop(uri);\n  }, [onStop]);\n\n  return (\n    <Pressable\n      accessibilityRole=\"button\"\n      accessibilityState={{ pressed: isRecording }}\n      onPress={isRecording ? stopAsync : startAsync}\n      style={{\n        padding: 16,\n        borderRadius: 999,\n        backgroundColor: isRecording ? '#c62828' : '#2962ff',\n        alignItems: 'center'\n      }}\n    >\n      <Text style={{ color: 'white', fontWeight: '600' }}>{isRecording ? 'Stop recording' : 'Start recording'}</Text>\n    </Pressable>\n  );\n}\n```"
    },
    {
      "type": "message",
      "role": "assistant",
      "speakerProvider": "openai",
      "content": "I'll layer on top of Claude's refactor with signal cancellation and a lightweight state machine so rapid taps don't race.```tsx\nconst [status, setStatus] = React.useState<'idle' | 'recording' | 'stopping'>('idle');\nconst actionRef = React.useRef<AbortController | null>(null);\n\nconst runSafely = React.useCallback(async (fn: () => Promise<void>) => {\n  actionRef.current?.abort();\n  const controller = new AbortController();\n  actionRef.current = controller;\n  try {\n    await fn();\n  } finally {\n    if (!controller.signal.aborted) actionRef.current = null;\n  }\n}, []);\n\nconst handlePress = React.useCallback(() => {\n  if (status === 'idle') {\n    setStatus('recording');\n    return runSafely(async () => {\n      await startAsync();\n      if (!actionRef.current?.signal.aborted) setStatus('recording');\n    });\n  }\n  if (status === 'recording') {\n    setStatus('stopping');\n    return runSafely(async () => {\n      await stopAsync();\n      if (!actionRef.current?.signal.aborted) setStatus('idle');\n    });\n  }\n}, [runSafely, startAsync, status, stopAsync]);\n```\nYou can surface the `status` in UI (spinner while stopping) and log analytic events at the boundaries." }
  ]
}
